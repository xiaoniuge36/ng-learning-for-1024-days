---
theme: juejin
highlight: tomorrow
---
**挑战坚持学习1024天——前端之JavaScript高级**

最近有阅读这一句话，编程除了算法和数据结构，什么也不属于我们。仔细思考下来会觉得很有道理，所谓程序员，有很多人被调侃为新时代农民工。其实本质上我们跟农民工干的活式一样的，我们没有所谓属于自己的东西，我们所学的技能都是站在巨人的肩膀上。每天写代码的过程中都像式在板砖，从这里搬到那里，可能真的属于我们自己的就只有数据结构算法了吧。但农民工也有底层顶层之分，也可以从农民工成长为架构师/cto。只要有梦并为之努力，会离自己向往的生活会越来越近。


js基础部分可到我文章专栏去看 ---[点击这里](https://juejin.cn/column/7123014837294235662)

# Day29【2022年8月22日】
**学习重点：** 浏览器的渲染原理（上）
浏览器工作原理参考网站
https://web.dev/howbrowserswork/
## 1.网页的解析过程
### 1.1解析一：HTML解析过程
**因为默认情况下服务器会给浏览器返回index.html文件，所以解析HTML是所有步骤的开始：解析HTML，会构建DOM Tree：**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe33e32dc4b7492e915311c28f463970~tplv-k3u1fbpfcp-watermark.image?)
### 1.2解析二：生成CSS规则
**在解析的过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件：**

- 注意：下载CSS文件是不会影响DOM的解析的；

**浏览器下载完CSS文件后，就会对CSS文件进行解析，解析出对应的规则树：**

- 我们可以称之为 CSSOM（CSS Object Model，CSS对象模型）；

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bf10f444add417695820bc3afa03df6~tplv-k3u1fbpfcp-watermark.image?)
### 1.3解析三 – 构建Render Tree
**当有了DOM Tree和 CSSOM Tree后，就可以两个结合来构建Render Tree了**
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4760a2c029b4147b0236d144ffe8da2~tplv-k3u1fbpfcp-watermark.image?)
**注意一：link元素不会阻塞DOM Tree的构建过程，但是会阻塞Render Tree的构建过程**

- 这是因为Render Tree在构建时，需要对应的CSSOM Tree；

**注意二：Render Tree和DOM Tree并不是一一对应的关系，比如对于display为none的元素，压根不会出现在render tree中；**
### 1.4解析四 – 布局（layout）和绘制（Paint）
**第四步是在渲染树（Render Tree）上运行布局（Layout）以计算每个节点的几何体。**

- 渲染树会表示显示哪些节点以及其他样式，但是不表示每个节点的尺寸、位置等信息；

- 布局是确定呈现树中所有节点的宽度、高度和位置信息；

**第五步是将每个节点绘制（Paint）到屏幕上**

- 在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点；

- 包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素（比如img）

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d2c4d315e74ddf91787b6501306595~tplv-k3u1fbpfcp-watermark.image?)
## 2.浏览器渲染流程
浏览器渲染主要有以下步骤：

-   首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
-   然后对 CSS 进行解析，生成 CSSOM 规则树。
-   根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
-   当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
-   布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。
流程如下图所示：

![8b9c27221d7203c311cbd48122fa9e0.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3316ce148b9149eaa1a0aa970191f272~tplv-k3u1fbpfcp-watermark.image?)
**注意**这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。
## 3.今日精进
人生中充满了很多选择，所以人生允满了很多变数。细小的选择影响心情，重大的选择影响人生，关健的的选择决定一生。不要抱怨，抱怨就是一种选择；要努力改变，这才是正确的选择，过去的选择造就了现在的人生，现在的选择决定了未来的人生，所以，学会积极吸收正能量的事物，这是关乎一生的选择。

#  Day30【2022年8月23日】
**学习重点：** 浏览器的渲染原理（下）
## 1.回流和重绘解析
### 1.1回流（重排）
#### 1.1.1理解回流reflow：（也可以称之为重排）
- 第一次确定节点的大小和位置，称之为布局（layout）。
- 之后对节点的大小、位置修改重新计算称之为回流。

#### 1.1.2什么情况下引起回流呢？

- 比如DOM结构发生改变（添加新的节点或者移除节点）；

- 比如改变了布局（修改了width、height、padding、font-size等值）

- 比如窗口resize（修改了窗口的尺寸等）

- 比如调用getComputedStyle方法获取尺寸、位置信息；
### 1.2重绘
#### 1.2.1理解重绘repaint： 
- 第一次渲染内容称之为绘制（paint）。
- 之后重新渲染称之为重绘。
#### 1.2.2什么情况下会引起重绘呢？
- 比如修改背景色、文字颜色、边框颜色、样式等；

**回流一定会引起重绘，所以回流是一件很消耗性能的事情。所以在开发中要尽量避免发生回流。**
**重绘不一定引起回流,而回流一定会引起重绘。**
### 1.3避免回流的方式
#### 1.3.1修改样式时尽量一次性修改
- 比如通过cssText修改，比如通过添加class修改

#### 1.3.2.尽量避免频繁的操作DOM

- 我们可以在一个DocumentFragment或者父元素中将要操作的DOM操作完成，再一次性的操作；

#### 1.3.3.尽量避免通过getComputedStyle获取尺寸、位置等信息；

#### 1.3.4.对某些元素使用position的absolute或者fixed

- 并不是不会引起回流，而是开销相对较小，不会对其他元素造成影响。

## 2.合成和性能优化
### 2.1特殊解析 – composite合成
**绘制的过程，可以将布局后的元素绘制到多个合成图层中。**

- 这是浏览器的一种优化手段；

**默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的；而一些特殊的属性，会创建一个新的合成层（ CompositingLayer ），并且新的图层可以利用GPU来加速绘制；**

- 因为每个合成层都是单独渲染的；

**那么哪些属性可以形成新的合成层呢？常见的一些属性：**

- 3D transforms

- video、canvas、iframe

- opacity 动画转换时；

- position: fixed

- will-change：一个实验性的属性，提前告诉浏览器元素可能发生哪些变化；

- animation 或 transition 设置了opacity、transform；

**分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。**

### 2.2性能优化
**（1）针对JavaScript：**JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：

（1）尽量将JavaScript文件放在body的最后

（2） body中间尽量不要写`<script>`标签

（3）`<script>`标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：

-   **script** 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
-   **async** 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；
-   **defer** 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。

**（2）针对CSS：**使用CSS有三种方式：使用**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：

-   **link**：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
-   **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
-   **style**：GUI直接渲染

外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。

所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。

**（3）针对DOM树、CSSOM树：**

可以通过以下几种方式来减少渲染的时间：

-   HTML文件的代码层级尽量不要太深
-   使用语义化的标签，来避免不标准语义化的特殊处理
-   减少CSSD代码的层级，因为选择器是从左向右进行解析的

**（4）减少回流与重绘：**

-   操作DOM时，尽量在低层级的DOM节点进行操作
-   不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
-   使用CSS的表达式
-   不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
-   使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
-   避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
-   将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
-   将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。

浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**

**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**

将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

## 3.defer和async属性
### 3.1script元素和页面解析的关系
**我们现在已经知道了页面的渲染过程，但是JavaScript在哪里呢？**

- 事实上，浏览器在解析HTML的过程中，遇到了script元素是不能继续构建DOM树的；

- 它会停止继续构建，首先下载JavaScript代码，并且执行JavaScript的脚本；

- 只有等到JavaScript脚本执行结束后，才会继续解析HTML，构建DOM树；

**为什么要这样做呢？**

- 这是因为JavaScript的作用之一就是操作DOM，并且可以修改DOM；

- 如果我们等到DOM树构建完成并且渲染再执行JavaScript，会造成严重的回流和重绘，影响页面的性能；

- 所以会在遇到script元素时，优先下载和执行JavaScript代码，再继续构建DOM树；

**但是这个也往往会带来新的问题，特别是现代页面开发中：**

- 在目前的开发模式中（比如Vue、React），脚本往往比HTML页面更“重”，处理时间需要更长；

- 所以会造成页面的解析阻塞，在脚本下载、执行完成之前，用户在界面上什么都看不到；

**为了解决这个问题，script元素给我们提供了两个属性（attribute）：defer和async。**
### 3.2defer属性
**表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。**
**defer 属性告诉浏览器不要等待脚本下载，而继续解析HTML，构建DOM Tree。**

- 脚本会由浏览器来进行下载，但是不会阻塞DOM Tree的构建过程；

- 如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMContentLoaded事件之前先执行defer中的代码；

**所以DOMContentLoaded总是会等待defer中的代码先执行完成。**

**另外多个带defer的脚本是可以保持正确的顺序执行的。**

**从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中；**

**注意：defer仅适用于外部脚本，对于script默认内容会被忽略**
### 3.3async属性
**表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。**
**async 特性与 defer 有些类似，它也能够让脚本不阻塞页面。**

**async是让一个脚本完全独立的：**

- 浏览器不会因 async 脚本而阻塞（与 defer 类似）；

- async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本；

- async不会能保证在DOMContentLoaded之前或者之后执行；

**defer通常用于需要在文档解析后操作DOM的JavaScript代码，并且对多个script文件有顺序要求的；**

**async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的；**

**二者的区别：**
标记为 async 的脚本并不保证能按照它们出现的次序执行，而defer可以按出现次序执行。

**实例**
```js
<!DOCTYPE html> 
<html> 
 <head> 
 <title>Example HTML Page</title> 
 <script async src="example1.js"></script> 
 <script async src="example2.js"></script> 
 </head> 
 <body> 
 <!-- 这里是页面内容 --> 
 </body> 
</html>
```
> 在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给脚本添加 async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本。**正因为如此，异步脚本不应该在加载期间修改 DOM。**
> 
**总结**
- 可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。

- 可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。

## 4.浏览器输入url到渲染的过程
![c7aa55d6c88f4928d2c54d5559a767e.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01532f5a7f454d158feaf42b2ee72a48~tplv-k3u1fbpfcp-watermark.image?)
## 5.今日精进
人生，敢闯才有机会；敢拼才有未来。大胆行动起来，想常人不敢想之事，做常人不敢做的决定，选择常人不敢选择的路。不拼一把，怎么知道自己行不行；不博一把，怎么知道自己能不能成功。没有勇气走出第一步，往往就是人生的分水岭，成功是被危险逼出来的，害怕危险，就等于拒绝成功。

浏览器渲染原理好文推荐---[传送门](https://juejin.cn/post/7134251423381848072)
#  Day31【2022年8月24日】
**学习重点：** JavaScript的运行原理
**认识v8引擎**
V8引擎，它是当下使用最广泛的 JavaScript 虚拟机，全球有超过 25 亿台安卓设备，而这些设备中都使用了 Chrome 浏览器，所以我们写的 JavaScript 应用，大都跑在 V8 上。

V8 是由 Google 开发的开源 JavaScript 引擎，是 JavaScript 虚拟机的一种，模拟实际计算机各种功能来实现代码的编译和执行。我们可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的 编程语言 JavaScript，翻译成机器能够理解的机器语言。目前主要用在 Chrome 浏览器和 Node.js 中。
## 1.V8引擎原理
### 1.1浏览器组成
**浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎：**
- 渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机
- JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互
- 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

**以webkit为例：**
- WebCore：负责HTML解析、布局、渲染等等相关的工作；
- JavaScriptCore：解析、执行JavaScrip

总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。
### 1.2V8引擎执行原理
官方对V8引擎的定义：
> V8 是 Google 的开源高性能 JavaScript 和 WebAssembly 引擎，用 C++ 编写。它用于 Chrome 和 Node.js 等。它实现了[ECMAScript](https://tc39.es/ecma262/)和[WebAssembly](https://webassembly.github.io/spec/core/)，并在 Windows 7 或更高版本、macOS 10.12+ 以及使用 x64、IA-32、ARM 或 MIPS 处理器的 Linux 系统上运行。V8 可以独立运行，也可以嵌入到任何 C++ 应用程序中。

![5439c59a9114a50e2fd2a79f5480820.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c324cb128db34729b91f31b2b4b0096d~tplv-k3u1fbpfcp-watermark.image?)
### 1.3v8引擎架构
#### 1.3.1 V8引擎本身的源码非常复杂，大概有超过100w行C++代码，通过了解它的架构，我们可以知道它是如何对JavaScript执行的：

#### 1.3.2 Parse模块会将JavaScript代码转换成AST（抽象语法树），这是因为解释器并不直接认识JavaScript代码；

- 如果函数没有被调用，那么是不会被转换成AST的；
- Parse的V8官方文档：https://v8.dev/blog/scanner

#### 1.3.3 Ignition是一个解释器，会将AST转换成ByteCode（字节码）

- 同时会收集TurboFan优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；
- 如果函数只调用一次，Ignition会解释执行ByteCode；
- Ignition的V8官方文档：https://v8.dev/blog/ignition-interpreter

#### 1.3.4 TurboFan是一个编译器，可以将字节码编译为CPU可以直接执行的机器码；
- 如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过TurboFan转换成优化的机器码，提高代码的执行性能；
- 但是，机器码实际上也会被还原为ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；
- TurboFan的V8官方文档：https://v8.dev/blog/turbofan-jit
#### 1.3.5 Orinoco 垃圾收集器(GC)
-负责将程序不再需要的内存空间回收。
- 主要式三个过程识别活/死对象、回收/重用死对象占用的内存、压缩/碎片整理内存（可选）
-官方文档：https://v8.dev/blog/trash-talk

**垃圾回收详情**

![7054e9c0998086699154ecdd34721e5.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13c07b0cdd604b1291138fd7c985b9e1~tplv-k3u1fbpfcp-watermark.image?)
**打标**
确定可以收集哪些对象是垃圾收集的重要组成部分。垃圾收集器通过使用可达性作为“活跃度”的代理来做到这一点。这意味着必须保留当前在运行时内可访问的任何对象，并且可以收集任何无法访问的对象。

标记是发现可达对象的过程。GC 从一组已知对象指针开始，称为根集。这包括执行堆栈和全局对象。然后它跟随每个指向 JavaScript 对象的指针，并将该对象标记为可访问。GC 跟踪该对象中的每个指针，并递归地继续此过程，直到找到并标记运行时中可到达的每个对象。

**扫地**
清除是一个过程，其中死对象留下的内存间隙被添加到称为空闲列表的数据结构中。标记完成后，GC 会发现无法访问的对象留下的连续间隙，并将它们添加到适当的空闲列表中。空闲列表由内存块的大小分隔，以便快速查找。将来当我们想要分配内存时，我们只需查看空闲列表并找到适当大小的内存块。

**压实**
主要 GC 还根据碎片启发式方法选择疏散/压缩某些页面。您可以认为压缩有点像旧 PC 上的硬盘碎片整理。我们将幸存的对象复制到当前未压缩的其他页面中（使用该页面的空闲列表）。这样，我们可以利用死对象留下的内存中的小而分散的间隙。

复制幸存对象的垃圾收集器的一个潜在弱点是，当我们分配大量长寿命对象时，我们为复制这些对象付出了高昂的代价。这就是为什么我们选择只压缩一些高度碎片化的页面，而只对其他页面执行清扫，这不会复制幸存的对象。
### 1.4 v8引擎官方解析图
![60d23a50efbfbb31b0a33ac785d3c37.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe439b2978214234a25071e6e997ae59~tplv-k3u1fbpfcp-watermark.image?)
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91259c410cb34df3bef6fb7679347d64~tplv-k3u1fbpfcp-watermark.image?)
## 2.js执行上下文
**js引擎会在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）**
- 该对象 所有的作用域（scope）都可以访问；
- 里面会包含Date、Array、String、Number、setTimeout、setInterval等等；
- 其中还有一个window属性指向自己；

**js引擎内部有一个执行上下文栈（Execution Context Stack，简称ECS），它是用于执行代码的调用栈。那么现在它要执行谁呢？执行的是全局的代码块：**

- 全局的代码块为了执行会构建一个 Global Execution Context（GEC）；
- GEC会 被放入到ECS中 执行；

**GEC被放入到ECS中里面包含两部分内容：**
- 第一部分：在代码执行前，在parser转成AST的过程中，会将全局定义的变量、函数等加入到GlobalObject中，但是并不会赋值；这个过程也称之为变量的作用域提升（hoisting）

- 第二部分：在代码执行中，对变量赋值，或者执行其他的函数；

**每一个执行上下文会关联一个VO（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中。**

**当全局代码被执行的时候，VO就是GO对象（全局对象）了**

## 1.执行上下文

> 执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定 、了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object）， 而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台 处理数据会用到它。

执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。

### 1.1 执行上下文类型类型

**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。全局上下文就是我们常说的 window 对象，因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。 **组成：**

-   全局对象（浏览器里是 Window, Node 环境下是 Global）
-   this 变量。这里的 this ，指向的还是全局变量

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。 **组成：**

-   函数上下文创建参数对象（arguments）；
-   this。动态的，如果它被一个引用对象调用，那么 this 就指向这个对象；否则，this 的值会被设置为全局对象或者 undefined（在严格模式下）

**（3）Eval 执行上下文**

执行在eval函数中的代码会有属于他自己的执行上下文，用的比较少了了解即可，跟面试官吹逼的时候可以用。

### 1.2 执行上下文栈--执行上下文的管理

-   JavaScript引擎使用执行上下文栈来管理执行上下文
-   当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

```
function testA() {
        console.log('执行第一个测试函数的逻辑');
        testB();
        console.log('再次执行第一个测试函数的逻辑');
      }
      
      function testB() {
        console.log('执行第二个测试函数的逻辑');
      }
      
      testA();
//执行第一个测试函数的逻辑
//执行第二个测试函数的逻辑
//再次执行第一个测试函数的逻辑
复制代码
```

执行顺序跟压入栈的顺序相反所以会先执行B-A-全局。 **特点：**

-   栈，先进后出
-   栈底永远是全局执行上下文环境window，其余的都是函数执行上下文
-   当前正在运行的永远是栈顶的执行上下文

### 1.3 创建执行上下文

创建执行上下文有两个阶段：**创建阶段**和**执行阶段**

**1）创建阶段**

（1）this绑定

-   在全局执行上下文中，this指向全局对象（window对象）
-   在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined

（2）创建词法环境组件

-   词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。
-   词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域

（3）创建变量环境组件

-   变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。

**2）执行阶段**

此阶段会完成对变量的分配，最后执行完代码。

整个过程是一个动态的过程。

**简单来说执行上下文就是指：**

在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

-   全局上下文：变量定义，函数声明
-   函数上下文：变量定义，函数声明，`this`，`arguments`

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

执行上下文与我基础部分一致，本篇重新复习一下可到基础部分查看----[点击这里](https://juejin.cn/post/7123421984767082533)

v8引擎好文推荐----[点击这里](https://blog.csdn.net/React_Community/article/details/123564717)
# 参考资料
-   JavaScript高级程序设计（第4版）
-  [MDN](https://developer.mozilla.org/en-US/)
-  coderwhy大神资料参考
#  结语

志同道合的小伙伴可以加我，一起交流进步，我们坚持每日精进（互相监督思考学习，如果坚持不下来我可以监督你）。另外共享学习资料的小伙伴也可以联系我，进群技术交流资料free共享，我们交换资料一起努力鸭！
——>[点击这里](https://juejin.cn/pin/7123425224455880740)

# 备注
按照时间顺序倒叙排列，完结后按时间顺序正序排列方便查看知识点,工作日更新。